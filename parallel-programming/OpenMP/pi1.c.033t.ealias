
;; Function fprintf (fprintf, funcdef_no=10, decl_uid=738, cgraph_uid=10, symbol_order=10)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__stream = &PARM_NOALIAS.0+32
PARM_NOALIAS.0+32 = &NONLOCAL
PARM_NOALIAS.64+64 = &NONLOCAL
PARM_NOALIAS.128+64 = &NONLOCAL
PARM_NOALIAS.192+64 = &NONLOCAL
PARM_NOALIAS.256+64 = &NONLOCAL
PARM_NOALIAS.320+64 = &NONLOCAL
PARM_NOALIAS.384+64 = &NONLOCAL
PARM_NOALIAS.448+64 = &NONLOCAL
PARM_NOALIAS.512+64 = &NONLOCAL
PARM_NOALIAS.576+64 = &NONLOCAL
PARM_NOALIAS.640+64 = &NONLOCAL
PARM_NOALIAS.704+64 = &NONLOCAL
PARM_NOALIAS.768+64 = &NONLOCAL
PARM_NOALIAS.832+64 = &NONLOCAL
PARM_NOALIAS.896+160 = &NONLOCAL
PARM_NOALIAS.1088+64 = &NONLOCAL
PARM_NOALIAS.1152+64 = &NONLOCAL
PARM_NOALIAS.1216+64 = &NONLOCAL
PARM_NOALIAS.1280+64 = &NONLOCAL
PARM_NOALIAS.1344+64 = &NONLOCAL
PARM_NOALIAS.1408+64 = &NONLOCAL
PARM_NOALIAS.1472+256 = &NONLOCAL
__fmt = &PARM_NOALIAS(32)
PARM_NOALIAS(32) = &NONLOCAL
ESCAPED = __stream
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_5 = NONLOCAL
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS.0+32 PARM_NOALIAS.64+64 PARM_NOALIAS.128+64 PARM_NOALIAS.192+64 PARM_NOALIAS.256+64 PARM_NOALIAS.320+64 PARM_NOALIAS.384+64 PARM_NOALIAS.448+64 PARM_NOALIAS.512+64 PARM_NOALIAS.576+64 PARM_NOALIAS.640+64 PARM_NOALIAS.704+64 PARM_NOALIAS.768+64 PARM_NOALIAS.832+64 PARM_NOALIAS.896+160 PARM_NOALIAS.1088+64 PARM_NOALIAS.1152+64 PARM_NOALIAS.1216+64 PARM_NOALIAS.1280+64 PARM_NOALIAS.1344+64 PARM_NOALIAS.1408+64 PARM_NOALIAS.1472+256 PARM_NOALIAS(32) }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__stream = { PARM_NOALIAS.0+32 }
PARM_NOALIAS.0+32 = { ESCAPED NONLOCAL }
PARM_NOALIAS.64+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.128+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.192+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.256+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.320+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.384+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.448+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.512+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.576+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.640+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.704+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.768+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.832+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.896+160 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1088+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1152+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1216+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1280+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1344+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1408+64 = { ESCAPED NONLOCAL }
PARM_NOALIAS.1472+256 = { ESCAPED NONLOCAL }
__fmt = { PARM_NOALIAS(32) }
PARM_NOALIAS(32) = { ESCAPED NONLOCAL }
__fprintf_chk = { }
_5 = { ESCAPED NONLOCAL }


Alias information for fprintf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3132 D.3133 } (nonlocal, escaped)

Flow-insensitive points-to information

__stream_2(D), points-to vars: { D.3132 } (nonlocal, escaped)
__fmt_3(D), points-to vars: { D.3133 } (nonlocal, escaped)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
fprintf (struct FILE * restrict __stream, const char * restrict __fmt)
{
  int _5;

  <bb 2>:
  _5 = __fprintf_chk (__stream_2(D), 1, __fmt_3(D), __builtin_va_arg_pack ());
  return _5;

}



;; Function printf (printf, funcdef_no=11, decl_uid=760, cgraph_uid=11, symbol_order=11)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3135 } (nonlocal, escaped)

Flow-insensitive points-to information

__fmt_2(D), points-to vars: { D.3135 } (nonlocal, escaped)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2>:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function atoi (atoi, funcdef_no=18, decl_uid=2448, cgraph_uid=18, symbol_order=18)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__nptr = &NONLOCAL
ESCAPED = __nptr
ESCAPED = &NULL
ESCAPED = &NONLOCAL
_4 = NONLOCAL
_5 = _4
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__nptr = { NONLOCAL }
strtol = { }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL } same as _4


Alias information for atoi

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

__nptr_2(D), points-to non-local, points-to vars: { }

__attribute__((__gnu_inline__, __pure__, __leaf__, __nothrow__))
atoi (const char * __nptr)
{
  long int _4;
  int _5;

  <bb 2>:
  _4 = strtol (__nptr_2(D), 0B, 10);
  _5 = (int) _4;
  return _5;

}



;; Function check_points (check_points, funcdef_no=28, decl_uid=3015, cgraph_uid=28, symbol_order=28)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
index = &NONLOCAL
num_points_per_thread = &NONLOCAL
seed = index
ESCAPED = &seed
_12 = NONLOCAL
_13 = _12
x_14 = _13
x_14 = &NONLOCAL
ESCAPED = &seed
_16 = NONLOCAL
_17 = _16
y_18 = _17
y_18 = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = index
ESCAPED = x_14
ESCAPED = y_18
_27 = NONLOCAL
_20 = x_14
_20 = x_14
_21 = y_18
_21 = y_18
_22 = _20
_22 = _21
local_count_23 = local_count_3
local_count_23 = &NONLOCAL
local_count_2 = local_count_3
local_count_2 = local_count_23
i_24 = i_1
i_24 = &NONLOCAL
i_1 = &NULL
i_1 = i_24
local_count_3 = &NULL
local_count_3 = local_count_2
ESCAPED = local_count_3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL seed }
NONLOCAL = { ESCAPED NONLOCAL } same as _12
STOREDANYTHING = { }
INTEGER = { ANYTHING }
index = { NONLOCAL }
num_points_per_thread = { NONLOCAL } same as index
seed = { ESCAPED NONLOCAL }
rand_r = { }
_12 = { ESCAPED NONLOCAL }
_13 = { ESCAPED NONLOCAL } same as _12
x_14 = { ESCAPED NONLOCAL } same as _12
_16 = { ESCAPED NONLOCAL } same as _12
_17 = { ESCAPED NONLOCAL } same as _12
y_18 = { ESCAPED NONLOCAL } same as _12
__printf_chk = { }
_27 = { ESCAPED NONLOCAL } same as _12
_20 = { ESCAPED NONLOCAL } same as _12
_21 = { ESCAPED NONLOCAL } same as _12
_22 = { ESCAPED NONLOCAL } same as _12
local_count_23 = { NULL NONLOCAL }
local_count_3 = { NULL NONLOCAL } same as local_count_23
local_count_2 = { NULL NONLOCAL } same as local_count_23
i_24 = { NULL NONLOCAL } same as local_count_23
i_1 = { NULL NONLOCAL } same as local_count_23


Alias information for check_points

Aliased symbols

seed, UID D.3017, unsigned int, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3017 } (escaped)

Flow-insensitive points-to information


check_points (unsigned int index, unsigned int num_points_per_thread)
{
  int D.3139;
  double y;
  double x;
  unsigned int local_count;
  unsigned int i;
  unsigned int seed;
  int _12;
  double _13;
  int _16;
  double _17;
  double _20;
  double _21;
  double _22;
  int _27;

  <bb 2>:
  seed = index_6(D);
  goto <bb 6>;

  <bb 3>:
  _12 = rand_r (&seed);
  _13 = (double) _12;
  x_14 = _13 / 2.147483647e+9;
  _16 = rand_r (&seed);
  _17 = (double) _16;
  y_18 = _17 / 2.147483647e+9;
  _27 = __printf_chk (1, "Thread %d - Point %f %f\n", index_6(D), x_14, y_18);
  _20 = x_14 * x_14;
  _21 = y_18 * y_18;
  _22 = _20 + _21;
  if (_22 <= 1.0e+0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  local_count_23 = local_count_3 + 1;

  <bb 5>:
  # local_count_2 = PHI <local_count_3(3), local_count_23(4)>
  i_24 = i_1 + 1;

  <bb 6>:
  # i_1 = PHI <0(2), i_24(5)>
  # local_count_3 = PHI <0(2), local_count_2(5)>
  if (i_1 < num_points_per_thread_10(D))
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 7>:
  seed ={v} {CLOBBER};
  return local_count_3;

}



;; Function main._omp_fn.0 (main._omp_fn.0, funcdef_no=30, decl_uid=3074, cgraph_uid=32, symbol_order=32)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
.omp_data_i = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
num_threads_12 = *.omp_data_i + 32
num_points_13 = *.omp_data_i
inside_points_2 = &NULL
inside_points_2 = inside_points_34
inside_points_2 = &NULL
_36 = .omp_data_i + 64
ESCAPED = _36
ESCAPED = inside_points_2
ESCAPED = &NULL
_15 = &NONLOCAL
_16 = _15
_17 = &NONLOCAL
_18 = _17
q.6_19 = num_threads_12
q.6_19 = _16
tt.7_20 = num_threads_12
tt.7_20 = _16
q.6_3 = q.6_22
q.6_3 = q.6_19
tt.7_4 = &NULL
tt.7_4 = tt.7_20
_23 = q.6_3
_23 = _18
_24 = tt.7_4
_24 = _23
_25 = q.6_3
_25 = _24
inside_points_1 = &NULL
inside_points_1 = inside_points_34
index_5 = _24
index_5 = index_35
_27 = num_points_13
_27 = num_threads_12
_28 = num_points_13
_28 = num_threads_12
iftmp.2_6 = &NONLOCAL
iftmp.2_6 = &NULL
num_points_per_thread_31 = iftmp.2_6
num_points_per_thread_31 = _27
ESCAPED = index_5
ESCAPED = num_points_per_thread_31
_33 = NONLOCAL
inside_points_34 = inside_points_1
inside_points_34 = _33
index_35 = index_5
index_35 = &NONLOCAL
q.6_22 = q.6_19
q.6_22 = &NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _33
STOREDANYTHING = { }
INTEGER = { ANYTHING }
.omp_data_i = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
num_threads_12 = { ESCAPED NONLOCAL }
num_points_13 = { ESCAPED NONLOCAL }
inside_points_2 = { NULL ESCAPED NONLOCAL }
inside_points_34 = { NULL ESCAPED NONLOCAL } same as inside_points_2
_36 = { PARM_NOALIAS(9) }
__atomic_fetch_add_4 = { }
omp_get_num_threads = { }
_15 = { NONLOCAL }
_16 = { NONLOCAL } same as _15
omp_get_thread_num = { }
_17 = { NONLOCAL } same as _15
_18 = { NONLOCAL } same as _15
q.6_19 = { ESCAPED NONLOCAL }
tt.7_20 = { ESCAPED NONLOCAL } same as q.6_19
q.6_3 = { ESCAPED NONLOCAL } same as q.6_19
q.6_22 = { ESCAPED NONLOCAL } same as q.6_19
tt.7_4 = { NULL ESCAPED NONLOCAL }
_23 = { ESCAPED NONLOCAL } same as q.6_19
_24 = { NULL ESCAPED NONLOCAL } same as tt.7_4
_25 = { NULL ESCAPED NONLOCAL } same as tt.7_4
inside_points_1 = { NULL ESCAPED NONLOCAL } same as inside_points_2
index_5 = { NULL ESCAPED NONLOCAL } same as tt.7_4
index_35 = { NULL ESCAPED NONLOCAL } same as tt.7_4
_27 = { ESCAPED NONLOCAL }
_28 = { ESCAPED NONLOCAL } same as _27
iftmp.2_6 = { NULL NONLOCAL }
num_points_per_thread_31 = { NULL ESCAPED NONLOCAL }
check_points = { }
_33 = { ESCAPED NONLOCAL }


Alias information for main._omp_fn.0

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3141 } (nonlocal, escaped)

Flow-insensitive points-to information

.omp_data_i_11(D), points-to vars: { D.3141 } (nonlocal, escaped)
_36, points-to vars: { D.3141 } (nonlocal, escaped)

main._omp_fn.0 (struct .omp_data_s.3 & restrict .omp_data_i)
{
  unsigned int num_points_per_thread;
  unsigned int index;
  unsigned int num_points;
  unsigned int num_threads;
  unsigned int inside_points;
  unsigned int q.6_3;
  unsigned int tt.7_4;
  unsigned int iftmp.2_6;
  int _15;
  unsigned int _16;
  int _17;
  unsigned int _18;
  unsigned int q.6_19;
  unsigned int tt.7_20;
  unsigned int q.6_22;
  unsigned int _23;
  unsigned int _24;
  unsigned int _25;
  unsigned int _27;
  unsigned int _28;
  unsigned int _33;
  unsigned int * _36;

  <bb 2>:
  num_threads_12 = *.omp_data_i_11(D).num_threads;
  num_points_13 = *.omp_data_i_11(D).num_points;
  if (num_threads_12 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  # inside_points_2 = PHI <0(5), inside_points_34(7), 0(2)>
  _36 = &.omp_data_i_11(D)->inside_points;
  __atomic_fetch_add_4 (_36, inside_points_2, 0);
  return;

  <bb 4>:
  _15 = __builtin_omp_get_num_threads ();
  _16 = (unsigned int) _15;
  _17 = __builtin_omp_get_thread_num ();
  _18 = (unsigned int) _17;
  q.6_19 = num_threads_12 / _16;
  tt.7_20 = num_threads_12 % _16;
  if (_18 < tt.7_20)
    goto <bb 9>;
  else
    goto <bb 5>;

  <bb 5>:
  # q.6_3 = PHI <q.6_22(9), q.6_19(4)>
  # tt.7_4 = PHI <0(9), tt.7_20(4)>
  _23 = q.6_3 * _18;
  _24 = tt.7_4 + _23;
  _25 = q.6_3 + _24;
  if (_24 >= _25)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 6>:
  # inside_points_1 = PHI <0(5), inside_points_34(7)>
  # index_5 = PHI <_24(5), index_35(7)>
  _27 = num_points_13 / num_threads_12;
  _28 = num_points_13 % num_threads_12;
  if (index_5 < _28)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  # iftmp.2_6 = PHI <1(8), 0(6)>
  num_points_per_thread_31 = iftmp.2_6 + _27;
  _33 = check_points (index_5, num_points_per_thread_31);
  inside_points_34 = inside_points_1 + _33;
  index_35 = index_5 + 1;
  if (_25 > index_35)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 8>:
  goto <bb 7>;

  <bb 9>:
  q.6_22 = q.6_19 + 1;
  goto <bb 5>;

}



;; Function main (main, funcdef_no=29, decl_uid=3027, cgraph_uid=29, symbol_order=29)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
argc = &NONLOCAL
argv = &NONLOCAL
stdout = NONLOCAL
stdout.0_5 = stdout
ESCAPED = stdout.0_5
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_42 = NONLOCAL
_10 = *argv + 64
ESCAPED = _10
ESCAPED = &NULL
ESCAPED = &NONLOCAL
_49 = NONLOCAL
_50 = _49
num_points_12 = _49
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = num_points_12
_48 = NONLOCAL
_15 = *argv + 128
ESCAPED = _15
ESCAPED = &NULL
ESCAPED = &NONLOCAL
_46 = NONLOCAL
_47 = _46
num_threads_17 = _46
_20 = NONLOCAL
stdout.0_21 = stdout
ESCAPED = stdout.0_21
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _20
_45 = NONLOCAL
ESCAPED = _47
_26 = NONLOCAL
stdout.0_27 = stdout
ESCAPED = stdout.0_27
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _26
_44 = NONLOCAL
.omp_data_o.5 = &NULL
.omp_data_o.5 = num_threads_17
.omp_data_o.5 = num_points_12
ESCAPED = &main._omp_fn.0
ESCAPED = &.omp_data_o.5
ESCAPED = &NULL
ESCAPED = &NULL
inside_points_33 = .omp_data_o.5
_35 = inside_points_33
_36 = _35
_36 = &NONLOCAL
_37 = num_points_12
pi_38 = _36
pi_38 = _37
stdout.0_39 = stdout
ESCAPED = stdout.0_39
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = pi_38
_43 = NONLOCAL
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL .omp_data_o.5 main._omp_fn.0 }
NONLOCAL = { ESCAPED NONLOCAL } same as stdout
STOREDANYTHING = { }
INTEGER = { ANYTHING }
argc = { NONLOCAL }
argv = { NONLOCAL } same as argc
stdout.0_5 = { ESCAPED NONLOCAL } same as stdout
stdout = { ESCAPED NONLOCAL }
__fprintf_chk = { }
_42 = { ESCAPED NONLOCAL } same as stdout
_10 = { ESCAPED NONLOCAL }
strtol = { }
_49 = { ESCAPED NONLOCAL } same as stdout
_50 = { ESCAPED NONLOCAL } same as stdout
num_points_12 = { ESCAPED NONLOCAL } same as stdout
__printf_chk = { }
_48 = { ESCAPED NONLOCAL } same as stdout
_15 = { ESCAPED NONLOCAL }
_46 = { ESCAPED NONLOCAL } same as stdout
_47 = { ESCAPED NONLOCAL } same as stdout
num_threads_17 = { ESCAPED NONLOCAL } same as stdout
omp_get_max_threads = { }
_20 = { ESCAPED NONLOCAL } same as stdout
stdout.0_21 = { ESCAPED NONLOCAL } same as stdout
_45 = { ESCAPED NONLOCAL } same as stdout
omp_set_num_threads = { }
_26 = { ESCAPED NONLOCAL } same as stdout
stdout.0_27 = { ESCAPED NONLOCAL } same as stdout
_44 = { ESCAPED NONLOCAL } same as stdout
.omp_data_o.5 = { NULL ESCAPED NONLOCAL } same as inside_points_33
GOMP_parallel = { }
main._omp_fn.0 = { ESCAPED NONLOCAL }
inside_points_33 = { NULL ESCAPED NONLOCAL }
_35 = { NULL ESCAPED NONLOCAL } same as inside_points_33
_36 = { NULL ESCAPED NONLOCAL } same as inside_points_33
_37 = { ESCAPED NONLOCAL } same as stdout
pi_38 = { NULL ESCAPED NONLOCAL } same as inside_points_33
stdout.0_39 = { ESCAPED NONLOCAL } same as stdout
_43 = { ESCAPED NONLOCAL } same as stdout


Alias information for main

Aliased symbols

.omp_data_o.5, UID D.3090, struct .omp_data_s.3, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3090 } (nonlocal, escaped)

Flow-insensitive points-to information

stdout.0_5, points-to non-local, points-to escaped, points-to vars: { }
argv_8(D), points-to non-local, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to vars: { }
_15, points-to non-local, points-to escaped, points-to vars: { }
stdout.0_21, points-to non-local, points-to escaped, points-to vars: { }
stdout.0_27, points-to non-local, points-to escaped, points-to vars: { }
stdout.0_39, points-to non-local, points-to escaped, points-to vars: { }

main (int argc, char * * argv)
{
  int D.3160;
  int D.3158;
  int D.3156;
  int D.3154;
  int D.3151;
  int D.3148;
  int D.3145;
  double pi;
  unsigned int inside_points;
  unsigned int num_threads;
  unsigned int num_points;
  struct .omp_data_s.3 .omp_data_o.5;
  struct _IO_FILE * stdout.0_5;
  char * _10;
  char * _15;
  int _20;
  struct _IO_FILE * stdout.0_21;
  int _26;
  struct _IO_FILE * stdout.0_27;
  double _35;
  double _36;
  double _37;
  struct _IO_FILE * stdout.0_39;
  int _42;
  int _43;
  int _44;
  int _45;
  long int _46;
  int _47;
  int _48;
  long int _49;
  int _50;

  <bb 2>:
  if (argc_3(D) != 3)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  stdout.0_5 = stdout;
  _42 = __fprintf_chk (stdout.0_5, 1, "Wrong number of parameters\n");
  goto <bb 5>;

  <bb 4>:
  _10 = MEM[(char * *)argv_8(D) + 8B];
  _49 = strtol (_10, 0B, 10);
  _50 = (int) _49;
  num_points_12 = (unsigned int) _49;
  _48 = __printf_chk (1, "Number of points is %d\n", num_points_12);
  _15 = MEM[(char * *)argv_8(D) + 16B];
  _46 = strtol (_15, 0B, 10);
  _47 = (int) _46;
  num_threads_17 = (unsigned int) _46;
  _20 = omp_get_max_threads ();
  stdout.0_21 = stdout;
  _45 = __fprintf_chk (stdout.0_21, 1, "%d\n", _20);
  omp_set_num_threads (_47);
  _26 = omp_get_max_threads ();
  stdout.0_27 = stdout;
  _44 = __fprintf_chk (stdout.0_27, 1, "%d\n", _26);
  .omp_data_o.5.inside_points = 0;
  .omp_data_o.5.num_threads = num_threads_17;
  .omp_data_o.5.num_points = num_points_12;
  __builtin_GOMP_parallel (main._omp_fn.0, &.omp_data_o.5, 0, 0);
  inside_points_33 = .omp_data_o.5.inside_points;
  .omp_data_o.5 ={v} {CLOBBER};
  _35 = (double) inside_points_33;
  _36 = _35 * 4.0e+0;
  _37 = (double) num_points_12;
  pi_38 = _36 / _37;
  stdout.0_39 = stdout;
  _43 = __fprintf_chk (stdout.0_39, 1, "Computed pi is %f\n", pi_38);

  <bb 5>:
  return 0;

}


